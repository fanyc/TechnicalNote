// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;


#define MOD3 float3(.1031,.11369,.13787)

float3 pow3(float3 v){
    return v * v * v;
}

float3 pow4(float3 v){
    return v * pow3(v);
}

float3 pow5(float3 v){
    return v * v * pow3(v);
}

float3 PerlinHash(float3 p3)
{
	p3 = frac(p3 * MOD3);
    p3 += dot(p3, p3.yxz+19.19);
    return -1.0 + 2.0 * frac(float3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));
}

float3 VoronoiHash(float3 v, float s){
 	v = fmod(v,s);
    v = float3(dot(v, float3(127.1,311.7,74.7)),
             dot(v, float3(269.5,183.3,246.1)),
             dot(v, float3(113.5,271.9,124.6)));
    return frac(sin(v)*43758.5453123);
}

float3 Voronoi(float3 v, float s, bool inverted){
 	v = v*s;
    v = v+0.5;
    float3 p = floor(v);
    float3 f = frac(v);
    
    float id = 0.0;
    float2 res = float2(1.0,1.0);
    for(int k=-1;k<=1;k++){
        for(int j=-1;j<=1;j++){
            for(int i=-1;i<=1;i++){
                float3 b = float3(i,j,k);
                float3 r = float3(b)-f+VoronoiHash(p+b, s);
                float d = dot(r,r);
                if(d<res.x){
                    id= dot(p+b, float3(1.0,57.0,113.0));
                    res = float2(d,res.x);
                }
                else if(d<res.y){
                    res.y = d;
                }
            }
        }
    }
    float2 result = res;
    id = abs(id);
    if(inverted)
        return float3(1.0-result, id);
    else
        return float3(result, id);
}

float Worley3Octaves(float3 p, float s){
	float3 xyz = p;
    
    float worleyV1 = Voronoi(xyz, 1.0*s, true).r;
    float worleyV2 = Voronoi(xyz, 2.0*s, false).r;
    float worleyV3 = Voronoi(xyz, 4.0*s, false).r;
    
    worleyV1 = clamp(worleyV1, 0.0, 1.0);
    worleyV2 = clamp(worleyV2, 0.0, 1.0);
    worleyV3 = clamp(worleyV3, 0.0, 1.0);
    
    float worleyV = worleyV1;
    worleyV = worleyV - worleyV2*0.3;
    worleyV = worleyV - worleyV3*0.3;
    return worleyV;
}

float Perlin(float3 p){
    float3 pi = floor(p);
    float3 pf = p - pi;
    
    float3 w = 6 * pow5(pf) - 15 * pow4(pf) + 10 * pow3(pf);
    
    return 	lerp(
        		lerp(
                	lerp(dot(pf - float3(0, 0, 0), PerlinHash(pi + float3(0, 0, 0))), 
                        dot(pf - float3(1, 0, 0), PerlinHash(pi + float3(1, 0, 0))),
                       	w.x),
                	lerp(dot(pf - float3(0, 0, 1), PerlinHash(pi + float3(0, 0, 1))), 
                        dot(pf - float3(1, 0, 1), PerlinHash(pi + float3(1, 0, 1))),
                       	w.x),
                	w.z),
        		lerp(
                    lerp(dot(pf - float3(0, 1, 0), PerlinHash(pi + float3(0, 1, 0))), 
                        dot(pf - float3(1, 1, 0), PerlinHash(pi + float3(1, 1, 0))),
                       	w.x),
                   	lerp(dot(pf - float3(0, 1, 1), PerlinHash(pi + float3(0, 1, 1))), 
                        dot(pf - float3(1, 1, 1), PerlinHash(pi + float3(1, 1, 1))),
                       	w.x),
                	w.z),
    			w.y);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

    Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
}
